---
title: "SVCFit Guide"
subtitle: 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SVCFit Guide}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=TRUE, message=FALSE}
library(SVCFit)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(igraph)
```

# Introduction

This guide provides a walkthrough of the SVCFit package, demonstrating its functionality and usage. We begin by showcasing an example of the input data format and how different functions within SVCFit process and modify it. Next, we present two additional sample datasets to illustrate how SVCFit's output can be visualized and interpreted. 


# Input to SVCFit

This is an example VCF file that would be generated by Manta [1] under *tumor_only* mode, so it doesn't have a column for read from matched normal sample.

```{r,echo = FALSE}
file_path <- system.file("extdata", "example.vcf", package = "SVCFit")
example_vcf <- read.table(file_path, quote="\"")
colnames(example_vcf)=c("CHROM",  "POS",     "ID",      "REF",     "ALT",     "QUAL",    "FILTER",  "INFO",    "FORMAT", "tumor")
```

```{r, echo=TRUE}
head(as_tibble(example_vcf))
```

This input data has `r nrow(example_vcf)` structural variants. Given this input data, let's see how SVCFit works!

# General workflow

## 1. Extract information from original VCF (extract_info)

This step assigns column names and extracts essential information for subsequent calculations and filtering. The key details extracted include reads, structural variant length, and coordinates. The command below includes `tumor_only=TRUE` since the input is generated without a matched normal sample, and sets `length_threshold=0` to include structural variants with lengths greater than 0.

```{r, message=FALSE}
vcf=extract_info(file_path, tumor_only=TRUE, length_threshold=0)
head(as_tibble(vcf))
```

In this step, Extract_info filters out structural variants that do not meet the criteria specified by the structural variant caller. Below are the filtered structural variants, where the FILTER column is not labeled as `PASS`.

```{r, echo = FALSE}
print(as_tibble(example_vcf[11,1:7]))
```

## 2. Check overlapping structural variants

This step determines whether structural variants are close enough to be grouped as a single variant. The command below indicates that `dat` and `compare` are the same file, signifying a self-comparison. In this case, overlapping structural variants within the file `vcf` will be merged into a single structural variant. 

```{r,message=FALSE}
checked=check_overlap(dat=vcf, compare=vcf, tolerance = 6)
```

During this step, the number of structural variants went from `r nrow(vcf)` to `r nrow(checked)`. 

Let's look at the overlapping structural variant below. We see that the start (POS) and end (pos2) genome coordinates for all three structural variants are within `tolerance=6`:

```{r, echo=FALSE}
head(as_tibble(vcf[c(38,39,42),c(1:7,11,12)]))
```


## 3. Calculate SVCF for structural variants

This step calculates the structural variant cellular fraction (SVCF) for all structural variants in the given VCF file.

```{r, echo = TRUE}
output <- calculate_svcf(checked, tumor_only=TRUE)
```

Finally, all of the above functionality is wrapped within a function SVCF(). Please refer to [our Github page](https://github.com/KarchinLab/SVCFit) for details on function arguments. 

```{r, echo=TRUE}
output = SVCF(file_path, overlap = TRUE, tumor_only = TRUE, length_threshold=0)
```

# Examples
Here, we show examples of SVCFit processing simulated single-clone and multiple-clone samples.
```{r, echo = TRUE, message=FALSE, fig.width=6, fig.height=3}
s_path <- system.file("extdata", "c40p50.0s22.bed.vcf", package = "SVCFit")
m_path <- system.file("extdata", "c50p50.0s18.bed.vcf", package = "SVCFit")
single = SVCF(s_path,tumor_only = TRUE, overlap = TRUE)%>%
  filter(svcf<1.1)
multiple = SVCF(m_path,tumor_only = TRUE, overlap = TRUE)%>%
  filter(svcf<1.1)

ps=single %>%
  ggplot()+
  geom_density(aes(x=svcf))+
  xlim(0,1.2)+
  geom_vline(aes(xintercept=0.5))+
  ggtitle("single-clone tumor sample")+ 
  theme(plot.title = element_text(size = 11))

pm=multiple %>%
  ggplot()+
  geom_density(aes(x=svcf))+
  xlim(0,1.2)+
  geom_vline(aes(xintercept=0.5))+
  ggtitle("multiple-clone tumor sample")+ 
  theme(plot.title = element_text(size = 11))

grid.arrange(ps, pm, nrow = 1, ncol = 2)
```

## Reference
1. Chen, X. et al. (2016) Manta: rapid detection of structural variants and indels for germline and cancer sequencing applications. Bioinformatics, 32, 1220-1222. <doi:10.1093/bioinformatics/btv710>
