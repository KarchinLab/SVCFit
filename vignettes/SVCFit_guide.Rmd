---
title: "SVCFit Guide"
subtitle: 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SVCFit Guide}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=TRUE, message=FALSE}
library(SVCFit)
library(tidyverse)
library(ggplot2)
library(gridExtra)
```

# Introduction

This guide provides a walkthrough of the SVCFit package, demonstrating its functionality and usage. We begin by showcasing an example of the input data format and how different functions within SVCFit process and modify it. Next, we present two additional sample datasets to illustrate how SVCFit's output can be visualized and interpreted. 


# Input to SVCFit

This example VCF file is outputed by Manta [1], the preferred output format by SVCFit.

```{r,echo = FALSE}
file_path <- system.file("extdata", "c50p70.0s32.bed.vcf", package = "SVCFit")
example_vcf <- read.table(file_path, quote="\"")
colnames(example_vcf)=c("CHROM",  "POS",     "ID",      "REF",     "ALT",     "QUAL",    "FILTER",  "INFO",    "FORMAT", "tumor")
```
```{r, echo=TRUE}
head(as_tibble(example_vcf))
```

Given this input data, let's see how SVCFit works. 

# General workflow

## 1. Extract information from original VCF (extract_info)

This step assigns column names and extracts key information for downstream calculation and filtering. Key information includes reads, structural variant length, and structural variant coordinates.

```{r, echo=TRUE}
vcf=extract_info(file_path, tumor_only=TRUE, length_threshold=0)
head(as_tibble(vcf))
```

During this step, Extract_info can filter out structural variants that didn't pass the filter criteria specified by structural variant caller. Below is an example where the FILTER column is not "PASS". 

```{r, echo = FALSE}
print(example_vcf[35,1:7])
```

## 2. Check overlapping structural variants

This step checks if structural variants are close enough to be considered as a single structural variant.

```{r, echo=TRUE}
checked=check_overlap(vcf, vcf)
```

During this step, the number of structural variants went from `r nrow(vcf)` to `r nrow(checked)`. 


## 3. Calculate SVCF for structural variants

This step calculates the structural variant cellular fraction (SVCF) for all structural variants in the input VCF file.

```{r, echo = TRUE}
output <- calculate_svcf(checked, tumor_only=TRUE)
```

Finally, all of the above functionality is wrapped within a function SVCF(). Please refer to [our Github page](https://github.com/KarchinLab/SVCFit) for details on function arguments. 

```{r, echo=TRUE}
output = SVCF(file_path, overlap = TRUE, tumor_only = TRUE, length_threshold=0)
```

# Examples
Here, we show examples of SVCFit processing simulated single-clone and multiple-clone samples.
```{r, echo = TRUE, message=FALSE, fig.width=6, fig.height=3}
s_path <- system.file("extdata", "c40p50.0s22.bed.vcf", package = "SVCFit")
m_path <- system.file("extdata", "c50p50.0s18.bed.vcf", package = "SVCFit")
single = SVCF(s_path,tumor_only = TRUE, overlap = TRUE)%>%
  filter(svcf<1.1)
multiple = SVCF(m_path,tumor_only = TRUE, overlap = TRUE)%>%
  filter(svcf<1.1)

ps=single %>%
  ggplot()+
  geom_density(aes(x=svcf))+
  xlim(0,1.2)+
  geom_vline(aes(xintercept=0.5))+
  ggtitle("single-clone tumor sample")+ 
  theme(plot.title = element_text(size = 11))

pm=multiple %>%
  ggplot()+
  geom_density(aes(x=svcf))+
  xlim(0,1.2)+
  geom_vline(aes(xintercept=0.5))+
  ggtitle("multiple-clone tumor sample")+ 
  theme(plot.title = element_text(size = 11))

grid.arrange(ps, pm, nrow = 1, ncol = 2)
```

## Reference
1. Chen, X. et al. (2016) Manta: rapid detection of structural variants and indels for germline and cancer sequencing applications. Bioinformatics, 32, 1220-1222. <doi:10.1093/bioinformatics/btv710>
