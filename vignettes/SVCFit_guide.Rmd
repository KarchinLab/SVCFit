---
title: "SVCFit Guide"
subtitle: 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SVCFit Guide}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=TRUE, message=FALSE}
library(SVCFit)
library(tidyverse)
library(ggplot2)
library(gridExtra)
```

# Introductin to SVCFit

SVCFit is a fast computational tool developed to estimate the structural variant cellular fraction (SVCF) of inversions, deletions and tandem duplications. The SVCF can be used to assign these structural variants to tumor clones and/or place them on a tumor evolutionary tree. Below describes how to use SVCFit with simulated data. 



# Input to SVCFit

The input should be in Variant Call Format (VCF) as output by the Manta package (cite). If you have a VCF output from a structural variant caller other than Manta, you can modify it to match Manta format.

```{r,echo = FALSE}
file_path <- system.file("extdata", "c50p70.0s32.bed.vcf", package = "SVCFit")
example_vcf <- read.table(file_path, quote="\"")
colnames(example_vcf)=c("CHROM",  "POS",     "ID",      "REF",     "ALT",     "QUAL",    "FILTER",  "INFO",    "FORMAT", "tumor")
#system.file("extdata", "c50p70.0s32.bed.vcf", package = "SVCFit")
str(example_vcf)
```


# General workflow
## 1. Extract information from original VCF (extract_info)

This step assigns column names and extracts key information for downstream calculation and filtering. Key information includes reads, structural variant length, and structural variant coordinates.

```{r,echo = FALSE}
vcf=extract_info(file_path, tumor_only=TRUE, length_threshold=0)
str(vcf)
```

After this step, the vcf now has `r nrow(vcf)` structural variants. Below shows the lost one structural variants because that the FILTER column is not PASS.

```{r, echo = FALSE}
print(example_vcf[35,1:7])
```


## 2. Check overlapping structural variants

This step checks if structural variants are close enough to be considered as a single structural variant.

```{r, echo = FALSE}
checked=check_overlap(vcf, vcf)
str(checked)
```

After checking overlaps, the vcf now has `r nrow(checked)` structural variants.


## 3. Calculate SVCF for structural variants

This step calculates the structural variant cellular fraction (SVCF) for all structural variants in the input VCF file.

```{r, echo = TRUE}
output <- calculate_svcf(checked, tumor_only=TRUE)
```

Finally, all of the above functionality is wrapped within a function SVCF()

```{r}
output = SVCF(file_path, overlap = TRUE, tumor_only = TRUE, length_threshold=0)
```

# Examples

```{r, echo = FALSE, message=FALSE, fig.width=6, fig.height=3}
s_path <- system.file("extdata", "c40p50.0s22.bed.vcf", package = "SVCFit")
m_path <- system.file("extdata", "c50p50.0s18.bed.vcf", package = "SVCFit")
single = SVCF(s_path,tumor_only = TRUE, overlap = TRUE)%>%
  filter(svcf<1.1)

multiple = SVCF(m_path,tumor_only = TRUE, overlap = TRUE)%>%
  filter(svcf<1.1)

ps=single %>%
  ggplot()+
  geom_density(aes(x=svcf))+
  xlim(0,1.2)+
  geom_vline(aes(xintercept=0.5))+
  ggtitle("single-clone tumor sample")+ 
  theme(plot.title = element_text(size = 11))

pm=multiple %>%
  ggplot()+
  geom_density(aes(x=svcf))+
  xlim(0,1.2)+
  geom_vline(aes(xintercept=0.5))+
  ggtitle("multiple-clone tumor sample")+ 
  theme(plot.title = element_text(size = 11))

grid.arrange(ps, pm, nrow = 1, ncol = 2)
```
