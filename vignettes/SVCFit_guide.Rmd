---
title: "SVCFit Guide"
subtitle: 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SVCFit Guide}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=TRUE, message=FALSE}
library(SVCFit)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(igraph)
library(GenomicRanges)

#data path
p_het=system.file("extdata", "examples/het_near_sv_c50p80m50.vcf", package = "SVCFit")
p_onsv=system.file("extdata", "examples/het_on_sv_c50p80m50.vcf", package = "SVCFit")
p_sv=system.file("extdata", "examples/example_sv.bed", package = "SVCFit")
p_cnv=system.file("extdata", "examples/c50p80m50.bed", package = "SVCFit")
p_truth=system.file("extdata", "examples/", package = "SVCFit")
tumor_only=FALSE
```

# Introduction

This guide provides a walkthrough of the SVCFit package, demonstrating its functionality and usage. We begin by showcasing an example of the input data format and how different functions within SVCFit process and modify it. Next, we present how SVCFit's output can be visualized and interpreted.

# Input to SVCFit

This is an example VCF file that would be generated by Svtyper[1] under given the output of Manta[2] with paired normal BAM.

```{r,echo = FALSE}
file_path <- system.file("extdata", "examples/example_sv.bed", package = "SVCFit")
example_vcf <- read.table(file_path, quote="\"")
colnames(example_vcf)=c("CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT", "normal", "tumor")
```

```{r, echo=TRUE}
head(example_vcf)
```

This input data has `r nrow(example_vcf)` structural variants. Given this input data, let's see how SVCFit works!

# General workflow

## 1. Extract information from original VCF (extract_info)

This step assigns column names and extracts essential information for subsequent calculations and filtering. The key details extracted include supporting reads, genomic locations and mutation types. This function internally calls 5 functions that can be run individually (details in section 4.1).

```{r, message=FALSE}
info=extract_info(p_het, p_onsv, p_sv, p_cnv, chr=NULL, 
                  flank_del=50, QUAL_tresh=100, min_alt=2, tumor_only)

data <- info[[1]]
sv_info <- info[[2]]
snp_df <- info[[3]]
sv_phase <- info[[4]]
```

## 2. Infer Zygosity and phasing

This step integrates CNV and heterozygous SNPs to infer phasing, zygosity, and overlapping CNV of an SV. The command requires the output from previous function `extract_info()`. This function internally calls 5 functions that can be run individually (details in section 4.2).

```{r}
anno_sv_cnv <- characterize_sv(sv_phase, sv_info, data[[4]])
head(anno_sv_cnv)
```

## 3. Calculate SVCF for structural variants

This step calculates the structural variant cellular fraction (SVCF) for all structural variants in the given VCF file. The command below includes:

-   `thresh=0.1` sets the minimum threshold to decide whether an SV occured before a CNV (higher value means stricter threshold).

```{r, echo = TRUE}
svcfit_out <- calc_svcf(anno_sv_cnv, sv_info, thresh=0.1, 'example', 'exp1')
head(svcfit_out)
```

## 4. Main functions breaksdown

Both `extract_info()` and `characterize_sv()` mentioned above contain functions that can be run individually without using the wrapper function.

### 4.1 `extract_info()`

-   `load_data()` load all input data given the path of where the files were saved. This function uses arguments:

| Argument | Type | Default | Description |
|----|----|----|----|
| `p_het` | Character | — | Path to VCF of heterozygous SNPs. |
| `p_onsv` | Character | — | Path to VCF of SNPs overlapping SV-supporting reads. |
| `p_sv` | Character | — | Path to SV VCF. |
| `p_cnv` | Character | — | Path to CNV file. |
| `chr_lst` | Character | NULL | Chromosomes to include. |
| `tumor_only` | Logical | FALSE | Whether SVs come from tumor-only calling. |

```{r}
data <- load_data(p_het, p_onsv, p_sv, p_cnv, chr=NULL, tumor_only)
```

-   `proc_bnd()` extracts translocations from SV input and annotate the them into 1) copy-paste translocation; 2) cut-paste translocation; 3) reciprocal translocation. This function uses arguments:

| Argument | Type | Default | Description |
|----|----|----|----|
| `sv` | data.frame | NULL | Input data for SV obatined from `load_data()`. |
| `flank_del` | numeric | 50 | Max distance to consider deletion overlapping a BND. |

```{r}
bnd_info <- proc_bnd(sv=data$sv, flank_del=50)
```

-   `parse_sv_info()` extracts information for SVs including: 1) genomic locations; 2) SV type; 3) SV supporting read count. Afterwards, this function filters the SV based on thier QUAL score and SV supporting read counts. This function uses arguments:

| Argument | Type | Default | Description |
|----|----|----|----|
| `sv` | data.frame | — | Input data for SVs obatined from `load_data()`. |
| `bnd` | data.frame | — | Output from `proc_bnd()` that contains annotated translocations. |
| `del` | data.frame | — | Output from `proc_bnd()` that contains deletion created by cut-paste translocation. |
| `QUAL_tresh` | numeric | 100 | Minimum QUAL score. |
| `min_alt` | numeric | 2 | Minimum alternative reads. |

```{r}
sv_info <- parse_sv_info(sv=data$sv, bnd=bnd_info$bnd, del=bnd_info$del, QUAL_tresh=100, min_alt=2)
```

-   `parse_het_snps()` extracts information for heterozygous SNPs detected near SVs. The information includes: 1) genomic locations; 2) allele type; 3) SNP supporting read counts. This function uses one argument:

| Argument | Type | Default | Description |
|----|----|----|----|
| `sv` | data.frame | — | Input data for heterozygous SNPs obatined from `load_data()`. |

```{r}
snp_df <- parse_het_snps(data$het_snp)
```

-   `parse_snp_on_sv()` extracts information for heterozygous SNPs detected on SV supporting reads. The information includes: 1) genomic locations; 2) allele type; 3) SNP supporting read counts. This function uses arguments:

| Argument | Type | Default | Description |
|----|----|----|----|
| `het_on_sv` | data.frame | — | Input data for heterozygous SNPs on SV suuporting reads obatined from `load_data()`. |
| `snp_df` | data.frame | — | Parsed SNP information from `parse_het_snps()`. |

```{r}
sv_phase <- parse_snp_on_sv(het_on_sv=data$het_on_sv, snp_df)
```

### 4.2 `characterize_sv()`

-   `assign_svids()` compares genomic locations between heterozygous SNPs and SVs to assign each heterozygous SNP to its overlapping SV. This function uses arguments:

| Argument    | Type       | Default | Description                       |
|-------------|------------|---------|-----------------------------------|
| `sv_phase`  | data.frame | —       | Phasing/zygosity from SNPs.       |
| `sv_info`   | data.frame | —       | Parsed SV metadata.               |
| `flank_snp` | numeric    | 500     | Max assignment distance for SNPs. |

```{r}
assign_id <- assign_svids(sv_phase, sv_info, flank_snp=500)
```

-   `sum_sv_info()` uses heterozygous SNPs near SVs to infer zygosity and phasing for each SV. This function uses arguments:

| Argument    | Type       | Default | Description                  |
|-------------|------------|---------|------------------------------|
| `sv_phase`  | data.frame | —       | Phasing/zygosity from SNPs.  |
| `sv_info`   | data.frame | —       | Parsed SV metadata.          |
| `assign_id` | data.frame | —       | CNV data from `load_data()`. |

```{r}
sv_sum <- sum_sv_info(sv_phase, assign_id, sv_info)
```

-   `2.3 assign_cnv()` compares genomic positions between SVs and CNVs to find any CNV overlapping with SVs. This function uses arguments:

| Argument | Type       | Default | Description                              |
|----------|------------|---------|------------------------------------------|
| `sv_sum` | data.frame | —       | SVs annotated with zygosity and phasing. |
| `cnv`    | data.frame | —       | CNV data from `load_data()`.             |

``` r
sv_cnv <- assign_cnv(sv_sum, cnv)
```

-   `2.4 annotate_cnv()`

```{r}
anno_sv_cnv <- annotate_cnv(sv_cnv)
```

## Additional functions

`load_truth` and `attach_truth` are only applicable to data from multiple-clone simulations where the clone assignment for each structural variants is known. In the example below, we see 4 structural variants included in this simulation:

```{r, echo=FALSE}
exper='exp1'
overlap=ifelse(exper=='exp1', FALSE, TRUE)
truth <- load_truth(p_truth, overlap)
svcfit_truth <- attach_truth(svcfit_out, truth)

```

## 
